import { McpServer } from "@modelcontextprotocol/sdk/server/mcp.js";
import { z } from "zod";
import { openDb } from "../db.js";

export const server = new McpServer({
  name: "User Stories MCP Server",
  version: "1.0.0",
});

// Tool r√©el : liste des projets depuis ta base
server.tool(
  "list_projects",
  "Retourne la liste des projets accessibles",
  {},
  async () => {
    const stmt = openDb().prepare(`
        SELECT *
        FROM projects p
        JOIN project_access pa ON pa.projectId = p.id
      `);
    let projects = stmt.all();
    // On parse settings avant la validation/s√©rialisation finale
    projects = projects.map((p) => ({
      ...p,
      settings: JSON.parse(p.settings),
    }));
    
    let summary = "## üìÅ Projets disponibles\n\n";
    projects.forEach(project => {
      const createdAt = new Date(project.createdAt).toLocaleDateString('fr-FR');
      summary += `### ${project.name}\n`;
      summary += `**ID:** ${project.id}\n`;
      summary += `**Cr√©√© le:** ${createdAt}\n`;
      summary += `**Propri√©taire:** ${project.ownerId}\n\n`;
    });
    
    return {
      content: [
        {
          type: "text",
          text: summary,
        },
      ],
    };
  }
);
  
// Exemple d'outil pour r√©cup√©rer le d√©tail d'un projet par ID
server.tool(
    "get_project_user_stories",
    "R√©cup√®re toutes les User stories d'un projet en fonction de son ID (‚ö†Ô∏è Pour les m√©triques, utilisez get_project_metrics √† la place)",
    { 
        projectId: z.string(),
        forMetrics: z.boolean().optional().default(false).describe("Si true, redirige vers get_project_metrics")
    },
    async ({ projectId, forMetrics = false }) => {
        // Si c'est pour des m√©triques, rediriger vers get_project_metrics
        if (forMetrics) {
            const db = openDb();
            const project = db.prepare("SELECT * FROM projects WHERE id = ?").get(projectId);
            if (!project) {
                return { content: [{ type: "text", text: "‚ùå Projet non trouv√© avec cet ID." }] };
            }
            
            // Appeler get_project_metrics directement
            const totalStories = db.prepare("SELECT COUNT(*) as count FROM user_stories WHERE projectId = ?").get(projectId);
            const completedStories = db.prepare("SELECT COUNT(*) as count FROM user_stories WHERE projectId = ? AND status = 'completed'").get(projectId);
            const inProgressStories = db.prepare("SELECT COUNT(*) as count FROM user_stories WHERE projectId = ? AND status = 'in_progress'").get(projectId);
            const todoStories = db.prepare("SELECT COUNT(*) as count FROM user_stories WHERE projectId = ? AND status = 'todo'").get(projectId);
            
            const completionRate = totalStories.count > 0 ? Math.round((completedStories.count / totalStories.count) * 100) : 0;
            
            let summary = `## üìä M√©triques du projet: ${project.name}\n\n`;
            summary += `### üéØ Progression globale\n`;
            summary += `**Taux de completion:** ${completionRate}%\n`;
            summary += `**Stories termin√©es:** ${completedStories.count}\n`;
            summary += `**Stories en cours:** ${inProgressStories.count}\n`;
            summary += `**Stories √† faire:** ${todoStories.count}\n\n`;
            
            return { content: [{ type: "text", text: summary }] };
        }
        const userStories = openDb()
            .prepare("SELECT * FROM user_stories WHERE projectId = ? ORDER BY priority DESC, createdAt DESC")
            .all(projectId);
        
        if (userStories.length === 0) {
            return { content: [{ type: "text", text: "‚ùå Aucune user story trouv√©e pour ce projet." }] };
        }
        
        let summary = `## üìã User Stories du projet (${userStories.length})\n\n`;
        summary += `> üí° **Note:** Pour les m√©triques d√©taill√©es du projet, utilisez l'outil **get_project_metrics** √† la place.\n\n`;
        
        // Grouper par statut
        const byStatus = {
            completed: userStories.filter(s => s.status === 'completed'),
            in_progress: userStories.filter(s => s.status === 'in_progress'),
            todo: userStories.filter(s => s.status === 'todo')
        };
        
        if (byStatus.completed.length > 0) {
            const displayCount = Math.min(byStatus.completed.length, 20); // Limiter √† 20 stories
            summary += `### ‚úÖ Termin√©es (${byStatus.completed.length} total, affichage des ${displayCount} plus r√©centes)\n`;
            byStatus.completed.slice(0, displayCount).forEach(story => {
                const priority = story.priority === 'high' ? 'üî¥' : story.priority === 'medium' ? 'üü°' : 'üü¢';
                summary += `${priority} **${story.title}** - ${story.complexity || '?'} points\n`;
            });
            if (byStatus.completed.length > displayCount) {
                summary += `... et ${byStatus.completed.length - displayCount} autres stories termin√©es\n`;
            }
            summary += '\n';
        }
        
        if (byStatus.in_progress.length > 0) {
            const displayCount = Math.min(byStatus.in_progress.length, 20);
            summary += `### üîÑ En cours (${byStatus.in_progress.length} total, affichage des ${displayCount} plus r√©centes)\n`;
            byStatus.in_progress.slice(0, displayCount).forEach(story => {
                const priority = story.priority === 'high' ? 'üî¥' : story.priority === 'medium' ? 'üü°' : 'üü¢';
                summary += `${priority} **${story.title}** - ${story.complexity || '?'} points\n`;
            });
            if (byStatus.in_progress.length > displayCount) {
                summary += `... et ${byStatus.in_progress.length - displayCount} autres stories en cours\n`;
            }
            summary += '\n';
        }
        
        if (byStatus.todo.length > 0) {
            const displayCount = Math.min(byStatus.todo.length, 20);
            summary += `### ‚è≥ √Ä faire (${byStatus.todo.length} total, affichage des ${displayCount} plus prioritaires)\n`;
            byStatus.todo.slice(0, displayCount).forEach(story => {
                const priority = story.priority === 'high' ? 'üî¥' : story.priority === 'medium' ? 'üü°' : 'üü¢';
                summary += `${priority} **${story.title}** - ${story.complexity || '?'} points\n`;
            });
            if (byStatus.todo.length > displayCount) {
                summary += `... et ${byStatus.todo.length - displayCount} autres stories √† faire\n`;
            }
            summary += '\n';
        }
        
        return { content: [{ type: "text", text: summary }] };
    }
);

// Nouvel outil : D√©tails complets d'une user story sp√©cifique
server.tool(
    "get_user_story_details",
    "R√©cup√®re les d√©tails complets d'une user story sp√©cifique avec ses d√©pendances, commentaires et m√©triques",
    { 
        userStoryId: z.string().describe("ID de la user story √† analyser"),
        includeDependencies: z.boolean().optional().default(true).describe("Inclure les d√©pendances"),
        includeComments: z.boolean().optional().default(true).describe("Inclure les commentaires"),
        includeMetrics: z.boolean().optional().default(true).describe("Inclure les m√©triques de progression")
    },
    async ({ userStoryId, includeDependencies = true, includeComments = true, includeMetrics = true }) => {
        const db = openDb();
        
        // R√©cup√©rer la user story principale
        const userStory = db.prepare("SELECT * FROM user_stories WHERE id = ?").get(userStoryId);
        
        if (!userStory) {
            return { 
                content: [{ 
                    type: "text", 
                    text: "‚ùå User story non trouv√©e avec cet ID." 
                }] 
            };
        }
        
        let summary = `## üìã User Story: ${userStory.title}\n\n`;
        summary += `| Propri√©t√© | Valeur |\n`;
        summary += `|-----------|--------|\n`;
        // G√©rer les diff√©rents formats de statut et priorit√©
        let statusText, priorityText;
        
        if (userStory.status === 'completed' || userStory.status === 'done') {
            statusText = '‚úÖ Termin√©e';
        } else if (userStory.status === 'in_progress' || userStory.status === 'inProgress') {
            statusText = 'üîÑ En cours';
        } else {
            statusText = '‚è≥ √Ä faire';
        }
        
        if (userStory.priority === 'high' || userStory.priority === 'Must Have') {
            priorityText = 'üî¥ Haute';
        } else if (userStory.priority === 'medium' || userStory.priority === 'Should Have') {
            priorityText = 'üü° Moyenne';
        } else if (userStory.priority === 'low' || userStory.priority === 'Could Have') {
            priorityText = 'üü¢ Basse';
        } else {
            priorityText = `‚ö™ ${userStory.priority}`;
        }
        
        summary += `| **Statut** | ${statusText} |\n`;
        summary += `| **Priorit√©** | ${priorityText} |\n`;
        summary += `| **Estimation** | ${userStory.estimation || 'Non d√©finie'} jours |\n`;
        summary += `| **Date de d√©but** | ${userStory.estimatedStartDate ? new Date(userStory.estimatedStartDate).toLocaleDateString('fr-FR') : 'Non d√©finie'} |\n`;
        summary += `| **Date de fin** | ${userStory.estimatedEndDate ? new Date(userStory.estimatedEndDate).toLocaleDateString('fr-FR') : 'Non d√©finie'} |\n\n`;
        summary += `### üìù Description\n\n`;
        summary += `> ${userStory.description || 'Aucune description'}\n\n`;
        
        // Ajouter les d√©pendances si demand√©
        if (includeDependencies) {
            const dependencies = db.prepare(`
                SELECT us.*, 
                       CASE WHEN d.dependencyType = 'blocks' THEN 'bloque' 
                            WHEN d.dependencyType = 'depends_on' THEN 'd√©pend de'
                            ELSE d.dependencyType END as relation
                FROM user_stories us
                JOIN dependencies d ON (d.blockingStoryId = us.id OR d.blockedStoryId = us.id)
                WHERE (d.blockingStoryId = ? OR d.blockedStoryId = ?)
                AND us.id != ?
            `).all(userStoryId, userStoryId, userStoryId);
            
            if (dependencies.length > 0) {
                summary += `## üîó D√©pendances (${dependencies.length})\n\n`;
                summary += `| Story | Statut | Relation |\n`;
                summary += `|-------|--------|----------|\n`;
                dependencies.forEach(dep => {
                    const status = dep.status === 'completed' ? '‚úÖ' : dep.status === 'in_progress' ? 'üîÑ' : '‚è≥';
                    summary += `| **${dep.title}** | ${status} | ${dep.relation} |\n`;
                });
                summary += '\n';
            }
        }
        
        // Ajouter les commentaires si demand√©
        if (includeComments) {
            const comments = db.prepare(`
                SELECT c.*, u.displayName as authorName
                FROM comments c
                LEFT JOIN users u ON c.authorId = u.id
                WHERE c.userStoryId = ?
                ORDER BY c.createdAt ASC
            `).all(userStoryId);
            
            if (comments.length > 0) {
                summary += `## üí¨ Commentaires (${comments.length})\n\n`;
                comments.forEach(comment => {
                    const date = new Date(comment.createdAt).toLocaleDateString('fr-FR');
                    summary += `### üí≠ ${comment.authorName || 'Anonyme'} - ${date}\n\n`;
                    summary += `> ${comment.content}\n\n`;
                });
            }
        }
        
        // Ajouter les m√©triques si demand√©
        if (includeMetrics) {
            const totalStories = db.prepare("SELECT COUNT(*) as count FROM user_stories WHERE projectId = ?").get(userStory.projectId);
            const completedStories = db.prepare("SELECT COUNT(*) as count FROM user_stories WHERE projectId = ? AND status = 'completed'").get(userStory.projectId);
            const estimationStats = db.prepare(`
                SELECT 
                    AVG(CAST(estimation AS INTEGER)) as avgEstimation,
                    MIN(CAST(estimation AS INTEGER)) as minEstimation,
                    MAX(CAST(estimation AS INTEGER)) as maxEstimation
                FROM user_stories 
                WHERE projectId = ? AND estimation IS NOT NULL
            `).get(userStory.projectId);
            
            const completionRate = totalStories.count > 0 ? Math.round((completedStories.count / totalStories.count) * 100) : 0;
            
            summary += `## üìä M√©triques du projet\n\n`;
            summary += `| M√©trique | Valeur |\n`;
            summary += `|----------|--------|\n`;
            summary += `| **Progression globale** | ${completionRate}% (${completedStories.count}/${totalStories.count}) |\n`;
                    summary += `| **Estimation moyenne** | ${Math.round(estimationStats.avgEstimation || 0)} jours |\n`;
        summary += `| **Estimation de cette story** | ${parseInt(userStory.estimation) || 0} jours |\n\n`;
        }
        
        return { 
            content: [{ 
                type: "text", 
                text: summary 
            }] 
        };
    }
);

// Nouvel outil : M√©triques d√©taill√©es du projet
server.tool(
    "get_project_metrics",
    "R√©cup√®re des m√©triques d√©taill√©es sur un projet : progression, v√©locit√©, burndown, r√©partition par statut et priorit√©",
    { 
        projectId: z.string().describe("ID du projet √† analyser"),
        includeSprintData: z.boolean().optional().default(true).describe("Inclure les donn√©es de sprint"),
        includeTrends: z.boolean().optional().default(true).describe("Inclure les tendances sur 30 jours")
    },
    async ({ projectId, includeSprintData = true, includeTrends = true }) => {
        const db = openDb();
        
        // V√©rifier que le projet existe
        const project = db.prepare("SELECT * FROM projects WHERE id = ?").get(projectId);
        if (!project) {
            return { 
                content: [{ 
                    type: "text", 
                    text: "‚ùå Projet non trouv√© avec cet ID." 
                }] 
            };
        }
        
        let summary = `## üìä M√©triques du projet: ${project.name}\n\n`;
        
        // M√©triques de base
        const totalStories = db.prepare("SELECT COUNT(*) as count FROM user_stories WHERE projectId = ?").get(projectId);
        const doneStories = db.prepare("SELECT COUNT(*) as count FROM user_stories WHERE projectId = ? AND status = 'done'").get(projectId);
        const inProgressStories = db.prepare("SELECT COUNT(*) as count FROM user_stories WHERE projectId = ? AND status = 'inProgress'").get(projectId);
        const todoStories = db.prepare("SELECT COUNT(*) as count FROM user_stories WHERE projectId = ? AND status = 'todo'").get(projectId);
        const blockedStories = db.prepare("SELECT COUNT(*) as count FROM user_stories WHERE projectId = ? AND status = 'blocked'").get(projectId);
        const toTestStories = db.prepare("SELECT COUNT(*) as count FROM user_stories WHERE projectId = ? AND status = 'toTest'").get(projectId);
        
        const completionRate = totalStories.count > 0 ? Math.round((doneStories.count / totalStories.count) * 100) : 0;
        
        summary += `### üéØ Progression globale\n\n`;
        summary += `| M√©trique | Valeur | Statut |\n`;
        summary += `|----------|--------|--------|\n`;
        summary += `| **Taux de completion** | ${completionRate}% | ${completionRate >= 80 ? '‚úÖ' : completionRate >= 60 ? 'üü°' : 'üî¥'} |\n`;
        summary += `| **Stories termin√©es** | ${doneStories.count} | ‚úÖ |\n`;
        summary += `| **Stories en cours** | ${inProgressStories.count} | üîÑ |\n`;
        summary += `| **Stories √† faire** | ${todoStories.count} | ‚è≥ |\n`;
        summary += `| **Stories en difficult√©** | ${blockedStories.count} | üöß |\n`;
        summary += `| **Stories √† recetter** | ${toTestStories.count} | üß™ |\n\n`;
        
        // R√©partition par priorit√©
        const priorityDistribution = db.prepare(`
            SELECT priority, COUNT(*) as count
            FROM user_stories 
            WHERE projectId = ?
            GROUP BY priority
            ORDER BY priority DESC
        `).all(projectId);
        
        if (priorityDistribution.length > 0) {
            summary += `### üî¥üü°üü¢ R√©partition par priorit√©\n\n`;
            summary += `| Priorit√© | Nombre | Pourcentage |\n`;
            summary += `|----------|--------|-------------|\n`;
            priorityDistribution.forEach(p => {
                // G√©rer les diff√©rents formats de priorit√©
                let icon, priorityName;
                if (p.priority === 'high' || p.priority === 'Must Have') {
                    icon = 'üî¥';
                    priorityName = 'Haute';
                } else if (p.priority === 'medium' || p.priority === 'Should Have') {
                    icon = 'üü°';
                    priorityName = 'Moyenne';
                } else if (p.priority === 'low' || p.priority === 'Could Have') {
                    icon = 'üü¢';
                    priorityName = 'Basse';
                } else {
                    icon = '‚ö™';
                    priorityName = p.priority;
                }
                const percentage = Math.round((p.count / totalStories.count) * 100);
                summary += `| ${icon} **${priorityName}** | ${p.count} | ${percentage}% |\n`;
            });
            summary += '\n';
        }
        
        // R√©partition par estimation (limit√© aux 10 plus fr√©quentes)
        const estimationDistribution = db.prepare(`
            SELECT estimation, COUNT(*) as count
            FROM user_stories 
            WHERE projectId = ? AND estimation IS NOT NULL
            GROUP BY estimation
            ORDER BY count DESC
            LIMIT 10
        `).all(projectId);
        
        if (estimationDistribution.length > 0) {
            summary += `### üìà R√©partition par estimation (top 10)\n\n`;
            summary += `| Jours | Nombre | Complexit√© |\n`;
            summary += `|--------|--------|------------|\n`;
            estimationDistribution.forEach(e => {
                const level = e.estimation <= 3 ? 'üü¢' : e.estimation <= 8 ? 'üü°' : 'üî¥';
                const complexity = e.estimation <= 3 ? 'Simple' : e.estimation <= 8 ? 'Moyenne' : 'Complexe';
                summary += `| **${e.estimation}** | ${e.count} | ${level} ${complexity} |\n`;
            });
            summary += '\n';
        }
        
        // M√©triques de v√©locit√© (si des sprints existent, limit√© aux 10 derniers)
        if (includeSprintData) {
            const sprintStories = db.prepare(`
                SELECT 
                    us.sprint,
                    COUNT(*) as totalStories,
                    SUM(CASE WHEN us.status = 'done' THEN 1 ELSE 0 END) as completedStories,
                    AVG(CAST(us.estimation AS INTEGER)) as avgEstimation
                FROM user_stories us
                WHERE us.projectId = ? AND us.sprint IS NOT NULL
                GROUP BY us.sprint
                ORDER BY CAST(us.sprint AS INTEGER) DESC
                LIMIT 10
            `).all(projectId);
            
            if (sprintStories.length > 0) {
                summary += `### üèÉ‚Äç‚ôÇÔ∏è V√©locit√© par sprint (10 derniers)\n\n`;
                summary += `| Sprint | Termin√©es/Total | Taux | Jours moy. | Performance |\n`;
                summary += `|--------|----------------|------|-------------|-------------|\n`;
                sprintStories.reverse().forEach(sprint => { // Remettre dans l'ordre chronologique
                    const completionRate = sprint.totalStories > 0 ? Math.round((sprint.completedStories / sprint.totalStories) * 100) : 0;
                    const status = completionRate >= 80 ? '‚úÖ' : completionRate >= 60 ? 'üü°' : 'üî¥';
                    const performance = completionRate >= 80 ? 'Excellent' : completionRate >= 60 ? 'Bon' : '√Ä am√©liorer';
                    summary += `| **Sprint ${sprint.sprint}** | ${sprint.completedStories}/${sprint.totalStories} | ${completionRate}% | ${Math.round(sprint.avgEstimation || 0)} | ${status} ${performance} |\n`;
                });
                summary += '\n';
            }
        }
        
        // Estimation du temps restant
        const avgEstimation = db.prepare(`
            SELECT AVG(CAST(estimation AS INTEGER)) as avg
            FROM user_stories 
            WHERE projectId = ? AND estimation IS NOT NULL
        `).get(projectId);
        
        const remainingStories = totalStories.count - doneStories.count;
        const estimatedRemainingDays = avgEstimation.avg ? Math.ceil(remainingStories * avgEstimation.avg / 2) : 0;
        
        summary += `### ‚è±Ô∏è Estimations\n\n`;
        summary += `| M√©trique | Valeur |\n`;
        summary += `|----------|--------|\n`;
        summary += `| **Estimation moyenne** | ${Math.round(avgEstimation.avg || 0)} jours |\n`;
        summary += `| **Stories restantes** | ${remainingStories} |\n`;
        summary += `| **Temps estim√©** | ${estimatedRemainingDays} jours |\n`;
        summary += `| **Hypoth√®se** | 2 jours/story |\n\n`;
        
        // Ajouter des insights bas√©s sur les donn√©es
        summary += `> üí° **Insights:** `;
        if (completionRate >= 80) {
            summary += `Excellent taux de completion ! Le projet progresse bien.`;
        } else if (completionRate >= 60) {
            summary += `Bon taux de completion. Consid√©rez identifier les blocages pour am√©liorer la v√©locit√©.`;
        } else {
            summary += `Taux de completion faible. Analysez les causes et ajustez la planification.`;
        }
        summary += `\n\n`;
        
        return { 
            content: [{ 
                type: "text", 
                text: summary 
            }] 
        };
    }
);

// Nouvel outil : Analyse de sprint
server.tool(
    "get_sprint_analysis",
    "Analyse d√©taill√©e d'un sprint sp√©cifique : burndown, v√©locit√©, blocages, et recommandations",
    { 
        projectId: z.string().describe("ID du projet"),
        sprintNumber: z.string().describe("Num√©ro du sprint √† analyser"),
        includeRecommendations: z.boolean().optional().default(true).describe("Inclure des recommandations d'am√©lioration")
    },
    async ({ projectId, sprintNumber, includeRecommendations = true }) => {
        const db = openDb();
        
        // R√©cup√©rer toutes les user stories du sprint
        const sprintStories = db.prepare(`
            SELECT * FROM user_stories 
            WHERE projectId = ? AND sprint = ?
            ORDER BY priority DESC, estimation DESC
        `).all(projectId, sprintNumber);
        
        if (sprintStories.length === 0) {
            return { 
                content: [{ 
                    type: "text", 
                    text: `‚ùå Aucune user story trouv√©e pour le sprint ${sprintNumber}.` 
                }] 
            };
        }
        
        let summary = `## üèÉ‚Äç‚ôÇÔ∏è Analyse du Sprint ${sprintNumber}\n\n`;
        summary += `**Total des stories:** ${sprintStories.length}\n\n`;
        
        // Statistiques de base
        const done = sprintStories.filter(s => s.status === 'done').length;
        const inProgress = sprintStories.filter(s => s.status === 'inProgress').length;
        const todo = sprintStories.filter(s => s.status === 'todo').length;
        const blocked = sprintStories.filter(s => s.status === 'blocked').length;
        const toTest = sprintStories.filter(s => s.status === 'toTest').length;
        const completionRate = Math.round((done / sprintStories.length) * 100);
        
        summary += `### üìä Statut du sprint\n\n`;
        summary += `| Statut | Nombre | Pourcentage |\n`;
        summary += `|--------|--------|-------------|\n`;
        summary += `| ‚úÖ **Termin√©es** | ${done} | ${Math.round((done / sprintStories.length) * 100)}% |\n`;
        summary += `| üîÑ **En cours** | ${inProgress} | ${Math.round((inProgress / sprintStories.length) * 100)}% |\n`;
        summary += `| ‚è≥ **√Ä faire** | ${todo} | ${Math.round((todo / sprintStories.length) * 100)}% |\n`;
        summary += `| üöß **En difficult√©** | ${blocked} | ${Math.round((blocked / sprintStories.length) * 100)}% |\n`;
        summary += `| üß™ **√Ä recetter** | ${toTest} | ${Math.round((toTest / sprintStories.length) * 100)}% |\n\n`;
        summary += `**Taux de completion global:** ${completionRate}% ${completionRate >= 80 ? '‚úÖ' : completionRate >= 60 ? 'üü°' : 'üî¥'}\n\n`;
        
        // Analyse d'estimation
        const validEstimations = sprintStories
            .filter(s => s.estimation && !isNaN(parseInt(s.estimation)))
            .map(s => parseInt(s.estimation));
        
        const totalEstimation = validEstimations.reduce((sum, e) => sum + e, 0);
        const completedEstimation = sprintStories
            .filter(s => s.status === 'done' && s.estimation && !isNaN(parseInt(s.estimation)))
            .reduce((sum, s) => sum + parseInt(s.estimation), 0);
        
        summary += `### üìà Analyse d'estimation\n\n`;
        summary += `| M√©trique | Valeur |\n`;
        summary += `|----------|--------|\n`;
        summary += `| **Jours totaux** | ${totalEstimation} |\n`;
        summary += `| **Jours termin√©s** | ${completedEstimation} |\n`;
        summary += `| **Jours restants** | ${totalEstimation - completedEstimation} |\n`;
        summary += `| **Estimation moyenne** | ${validEstimations.length > 0 ? Math.round(totalEstimation / validEstimations.length) : 0} jours |\n`;
        summary += `| **Progression jours** | ${totalEstimation > 0 ? Math.round((completedEstimation / totalEstimation) * 100) : 0}% |\n\n`;
        
        // Analyse des blocages
        const blockedStories = db.prepare(`
            SELECT us.*, d.dependencyType
            FROM user_stories us
            JOIN dependencies d ON (d.blockingStoryId = us.id OR d.blockedStoryId = us.id)
            WHERE us.projectId = ? AND us.sprint = ?
        `).all(projectId, sprintNumber);
        
        if (blockedStories.length > 0) {
            summary += `### üöß Stories bloqu√©es (${blockedStories.length})\n\n`;
            summary += `| Story | Statut | Type de d√©pendance |\n`;
            summary += `|-------|--------|-------------------|\n`;
            blockedStories.forEach(story => {
                const status = story.status === 'completed' ? '‚úÖ' : story.status === 'in_progress' ? 'üîÑ' : '‚è≥';
                summary += `| **${story.title}** | ${status} | ${story.dependencyType} |\n`;
            });
            summary += '\n';
        }
        
        // Recommandations
        if (includeRecommendations) {
            const recommendations = [];
            
            if (completionRate < 70) {
                recommendations.push("üî¥ **Taux de completion faible:** Consid√©rez r√©duire la charge du sprint ou identifier les blocages.");
            }
            
            if (blockedStories.length > 0) {
                recommendations.push("üî¥ **Stories bloqu√©es:** Priorisez la r√©solution des d√©pendances.");
            }
            
            const highEstimation = validEstimations.filter(e => e > 8).length;
            if (highEstimation > validEstimations.length / 2) {
                recommendations.push("üü° **Trop de stories avec estimation √©lev√©e:** Consid√©rez d√©composer les stories de haute estimation.");
            }
            
            if (recommendations.length > 0) {
                summary += `### üí° Recommandations\n\n`;
                recommendations.forEach(rec => {
                    summary += `- [ ] ${rec}\n`;
                });
                summary += '\n';
            }
        }
        
        return { 
            content: [{ 
                type: "text", 
                text: summary 
            }] 
        };
    }
);

// Cr√©ation d'une user story
server.tool(
  "create_user_story",
  "Cr√©e une nouvelle user story dans le projet sp√©cifi√©.",
  {
    projectId: z.string(),
    epic: z.string().optional(),
    userRole: z.string().optional(),
    title: z.string(),
    justification: z.string().optional(),
    estimation: z.number().int().optional(),
    priority: z.string().optional(),
    dependency: z.string().optional(),
    acceptanceCriteria: z.string().optional(),
    status: z.string().optional(),
  },
  async (params) => {
    const db = openDb();
    const id = `${Date.now()}-${Math.floor(Math.random()*10000)}`;
    db.prepare(`INSERT INTO user_stories (id, projectId, epic, userRole, title, justification, estimation, priority, dependency, acceptanceCriteria, status, "order") VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)`)
      .run(
        id,
        params.projectId,
        params.epic || null,
        params.userRole || null,
        params.title,
        params.justification || null,
        params.estimation || null,
        params.priority || null,
        params.dependency || null,
        params.acceptanceCriteria || null,
        params.status || "todo",
        Date.now()
      );
    const story = db.prepare("SELECT * FROM user_stories WHERE id = ?").get(id);
    return {
      content: [{
        type: "text",
        text: `‚úÖ Nouvelle user story cr√©√©e :\n\n- **ID** : ${story.id}\n- **Titre** : ${story.title}\n- **Statut** : ${story.status}\n- **Priorit√©** : ${story.priority || "-"}\n- **Estimation** : ${story.estimation || "-"}\n- **Epic** : ${story.epic || "-"}`
      }]
    };
  }
);

// Mise √† jour de chaque champ
const updateFields = [
  { name: "title", label: "Titre" },
  { name: "epic", label: "Epic" },
  { name: "userRole", label: "R√¥le utilisateur" },
  { name: "justification", label: "Justification" },
  { name: "estimation", label: "Estimation" },
  { name: "priority", label: "Priorit√©" },
  { name: "dependency", label: "D√©pendance" },
  { name: "acceptanceCriteria", label: "Crit√®res d'acceptation" },
  { name: "status", label: "Statut" },
];

for (const field of updateFields) {
  server.tool(
    `update_user_story_${field.name}`,
    `Met √† jour le champ ${field.label} d'une user story par son ID.`,
    {
      id: z.string(),
      value: z.any(),
    },
    async ({ id, value }) => {
      const db = openDb();
      const story = db.prepare("SELECT * FROM user_stories WHERE id = ?").get(id);
      if (!story) {
        return { content: [{ type: "text", text: `‚ùå User story non trouv√©e avec l'ID ${id}` }] };
      }
      db.prepare(`UPDATE user_stories SET ${field.name} = ? WHERE id = ?`).run(value, id);
      const updated = db.prepare("SELECT * FROM user_stories WHERE id = ?").get(id);
      return {
        content: [{
          type: "text",
          text: `‚úèÔ∏è User story modifi√©e :\n\n- **ID** : ${updated.id}\n- **Titre** : ${updated.title}\n- **${field.label}** : ${updated[field.name]}`
        }]
      };
    }
  );
}

// Suppression d'une user story
server.tool(
  "delete_user_story",
  "Supprime une user story par son ID.",
  {
    id: z.string(),
  },
  async ({ id }) => {
    const db = openDb();
    const story = db.prepare("SELECT * FROM user_stories WHERE id = ?").get(id);
    if (!story) {
      return { content: [{ type: "text", text: `‚ùå User story non trouv√©e avec l'ID ${id}` }] };
    }
    db.prepare("DELETE FROM user_stories WHERE id = ?").run(id);
    return {
      content: [{ type: "text", text: `üóëÔ∏è User story supprim√©e :\n\n- **ID** : ${story.id}\n- **Titre** : ${story.title}` }]
    };
  }
);

// Filtrage avanc√© des user stories
server.tool(
  "get_filtered_user_stories",
  "Filtre et affiche les user stories selon des crit√®res sp√©cifiques : statut, epic, priorit√©, estimation, dates, crit√®res d'acceptation",
  {
    projectId: z.string().describe("ID du projet"),
    status: z.string().optional().describe("Filtrer par statut (done, inProgress, todo, blocked, toTest)"),
    epic: z.string().optional().describe("Filtrer par epic (recherche partielle)"),
    priority: z.string().optional().describe("Filtrer par priorit√© (high, medium, low)"),
    minEstimation: z.number().optional().describe("Estimation minimale en jours"),
    maxEstimation: z.number().optional().describe("Estimation maximale en jours"),
    startDate: z.string().optional().describe("Date de d√©but pour le filtrage par p√©riode (YYYY-MM-DD)"),
    endDate: z.string().optional().describe("Date de fin pour le filtrage par p√©riode (YYYY-MM-DD)"),
    hasAcceptanceCriteria: z.boolean().optional().describe("Filtrer par pr√©sence de crit√®res d'acceptation (true/false)"),
    orderBy: z.string().optional().default("order").describe("Champ de tri (order, title, priority, estimation, status)"),
    orderDirection: z.string().optional().default("ASC").describe("Direction du tri (ASC/DESC)"),
    limit: z.number().optional().describe("Limite du nombre de r√©sultats")
  },
  async (params) => {
    const db = openDb();
    
    // V√©rifier que le projet existe
    const project = db.prepare("SELECT * FROM projects WHERE id = ?").get(params.projectId);
    if (!project) {
      return { 
        content: [{ 
          type: "text", 
          text: "‚ùå Projet non trouv√© avec cet ID." 
        }] 
      };
    }
    
    let query = "SELECT * FROM user_stories WHERE projectId = ?";
    let queryParams = [params.projectId];
    
    // Appliquer les filtres
    if (params.status) {
      query += " AND status = ?";
      queryParams.push(params.status);
    }
    
    if (params.epic) {
      query += " AND epic LIKE ?";
      queryParams.push(`%${params.epic}%`);
    }
    
    if (params.priority) {
      query += " AND priority = ?";
      queryParams.push(params.priority);
    }
    
    if (params.minEstimation !== undefined) {
      query += " AND estimation >= ?";
      queryParams.push(params.minEstimation);
    }
    
    if (params.maxEstimation !== undefined) {
      query += " AND estimation <= ?";
      queryParams.push(params.maxEstimation);
    }
    
    if (params.startDate && params.endDate) {
      query += " AND estimatedStartDate BETWEEN ? AND ?";
      queryParams.push(params.startDate, params.endDate);
    }
    
    if (params.hasAcceptanceCriteria === true) {
      query += " AND acceptanceCriteria IS NOT NULL AND acceptanceCriteria != '[]' AND acceptanceCriteria != ''";
    }
    
    if (params.hasAcceptanceCriteria === false) {
      query += " AND (acceptanceCriteria IS NULL OR acceptanceCriteria = '[]' OR acceptanceCriteria = '')";
    }
    
    // Tri
    const orderBy = params.orderBy || "order";
    const orderDirection = params.orderDirection || "ASC";
    // Utiliser des guillemets pour √©viter les conflits avec les mots r√©serv√©s SQL
    const safeOrderBy = orderBy === "order" ? '"order"' : orderBy;
    query += ` ORDER BY ${safeOrderBy} ${orderDirection}`;
    
    // Limite
    if (params.limit) {
      query += " LIMIT ?";
      queryParams.push(params.limit);
    }
    
    const filteredStories = db.prepare(query).all(...queryParams);
    
    if (filteredStories.length === 0) {
      return { 
        content: [{ 
          type: "text", 
          text: "‚ùå Aucune user story trouv√©e avec les crit√®res sp√©cifi√©s." 
        }] 
      };
    }
    
    // Formater le r√©sultat
    let summary = `## üîç User Stories filtr√©es (${filteredStories.length})\n\n`;
    
    // Ajouter les crit√®res de filtrage utilis√©s
    const filters = [];
    if (params.status) filters.push(`Statut: ${params.status}`);
    if (params.epic) filters.push(`Epic: ${params.epic}`);
    if (params.priority) filters.push(`Priorit√©: ${params.priority}`);
    if (params.minEstimation !== undefined) filters.push(`Estimation min: ${params.minEstimation} jours`);
    if (params.maxEstimation !== undefined) filters.push(`Estimation max: ${params.maxEstimation} jours`);
    if (params.startDate && params.endDate) filters.push(`P√©riode: ${params.startDate} √† ${params.endDate}`);
    if (params.hasAcceptanceCriteria === true) filters.push(`Avec crit√®res d'acceptation`);
    if (params.hasAcceptanceCriteria === false) filters.push(`Sans crit√®res d'acceptation`);
    
    if (filters.length > 0) {
      summary += `### üìã Crit√®res de filtrage\n`;
      filters.forEach(filter => {
        summary += `- ${filter}\n`;
      });
      summary += '\n';
    }
    
    // Grouper par statut
    const byStatus = {
      done: filteredStories.filter(s => s.status === 'done'),
      inProgress: filteredStories.filter(s => s.status === 'inProgress'),
      todo: filteredStories.filter(s => s.status === 'todo'),
      blocked: filteredStories.filter(s => s.status === 'blocked'),
      toTest: filteredStories.filter(s => s.status === 'toTest')
    };
    
    if (byStatus.done.length > 0) {
      summary += `### ‚úÖ Termin√©es (${byStatus.done.length})\n`;
      byStatus.done.forEach(story => {
        const priority = story.priority === 'high' ? 'üî¥' : story.priority === 'medium' ? 'üü°' : 'üü¢';
        summary += `${priority} **${story.title}** - ${story.estimation || '?'} jours`;
        if (story.epic) summary += ` (${story.epic})`;
        summary += '\n';
      });
      summary += '\n';
    }
    
    if (byStatus.inProgress.length > 0) {
      summary += `### üîÑ En cours (${byStatus.inProgress.length})\n`;
      byStatus.inProgress.forEach(story => {
        const priority = story.priority === 'high' ? 'üî¥' : story.priority === 'medium' ? 'üü°' : 'üü¢';
        summary += `${priority} **${story.title}** - ${story.estimation || '?'} jours`;
        if (story.epic) summary += ` (${story.epic})`;
        summary += '\n';
      });
      summary += '\n';
    }
    
    if (byStatus.todo.length > 0) {
      summary += `### ‚è≥ √Ä faire (${byStatus.todo.length})\n`;
      byStatus.todo.forEach(story => {
        const priority = story.priority === 'high' ? 'üî¥' : story.priority === 'medium' ? 'üü°' : 'üü¢';
        summary += `${priority} **${story.title}** - ${story.estimation || '?'} jours`;
        if (story.epic) summary += ` (${story.epic})`;
        summary += '\n';
      });
      summary += '\n';
    }
    
    if (byStatus.blocked.length > 0) {
      summary += `### üöß En difficult√© (${byStatus.blocked.length})\n`;
      byStatus.blocked.forEach(story => {
        const priority = story.priority === 'high' ? 'üî¥' : story.priority === 'medium' ? 'üü°' : 'üü¢';
        summary += `${priority} **${story.title}** - ${story.estimation || '?'} jours`;
        if (story.epic) summary += ` (${story.epic})`;
        summary += '\n';
      });
      summary += '\n';
    }
    
    if (byStatus.toTest.length > 0) {
      summary += `### üß™ √Ä recetter (${byStatus.toTest.length})\n`;
      byStatus.toTest.forEach(story => {
        const priority = story.priority === 'high' ? 'üî¥' : story.priority === 'medium' ? 'üü°' : 'üü¢';
        summary += `${priority} **${story.title}** - ${story.estimation || '?'} jours`;
        if (story.epic) summary += ` (${story.epic})`;
        summary += '\n';
      });
      summary += '\n';
    }
    
    summary = summary.replace(/\\n/g, '\n');
    
    return { 
      content: [{ 
        type: "text", 
        text: summary 
      }] 
    };
  }
);
