import express from "express";
import { OpenAI } from "openai";

const router = express.Router();

// Import direct des fonctions MCP
import { openDb } from "./db.js";

// Fonction pour lister les projets
async function listProjects() {
	try {
		const stmt = openDb().prepare(`
			SELECT *
			FROM projects p
			JOIN project_access pa ON pa.projectId = p.id
		`);
		let projects = stmt.all();
		// On parse settings avant la validation/s√©rialisation finale
		projects = projects.map((p) => ({
			...p,
			settings: JSON.parse(p.settings),
		}));
		return projects;
	} catch (error) {
		console.error("Erreur lors de la r√©cup√©ration des projets:", error);
		throw error;
	}
}

// Fonction pour r√©cup√©rer les user stories d'un projet
async function getProjectUserStories(projectId) {
	try {
		const userStories = openDb()
			.prepare("SELECT * FROM user_stories WHERE projectId = ?")
			.all(projectId);
		return userStories;
	} catch (error) {
		console.error("Erreur lors de la r√©cup√©ration des user stories:", error);
		throw error;
	}
}

// Fonction pour ex√©cuter les outils MCP directement
async function executeMcpTool(toolCall) {
	try {
		const { name, arguments: args } = toolCall.function;
		const parsedArgs = JSON.parse(args);
		
		switch (name) {
			case "list_projects":
				const projects = await listProjects();
				return projects;
				
			case "get_project_user_stories":
				const userStories = await getProjectUserStories(parsedArgs.projectId);
				return userStories;
				
			case "get_user_story_details":
			case "get_sprint_analysis":
				// Pour l'instant, retourner un message d'information
				return `‚ÑπÔ∏è L'outil ${name} n'est pas encore impl√©ment√© dans cette version. Utilisez get_project_metrics pour les m√©triques du projet.`;
				
			case "get_filtered_user_stories":
				const dbFiltered = openDb();
				let query = "SELECT * FROM user_stories WHERE projectId = ?";
				let params = [parsedArgs.projectId];
				
				// Filtres disponibles
				if (parsedArgs.status) {
					query += " AND status = ?";
					params.push(parsedArgs.status);
				}
				
				if (parsedArgs.epic) {
					query += " AND epic LIKE ?";
					params.push(`%${parsedArgs.epic}%`);
				}
				
				if (parsedArgs.priority) {
					query += " AND priority = ?";
					params.push(parsedArgs.priority);
				}
				
				if (parsedArgs.minEstimation) {
					query += " AND estimation >= ?";
					params.push(parsedArgs.minEstimation);
				}
				
				if (parsedArgs.maxEstimation) {
					query += " AND estimation <= ?";
					params.push(parsedArgs.maxEstimation);
				}
				
				if (parsedArgs.startDate && parsedArgs.endDate) {
					query += " AND estimatedStartDate BETWEEN ? AND ?";
					params.push(parsedArgs.startDate, parsedArgs.endDate);
				}
				
				if (parsedArgs.hasAcceptanceCriteria === true) {
					query += " AND acceptanceCriteria IS NOT NULL AND acceptanceCriteria != '[]' AND acceptanceCriteria != ''";
				}
				
				if (parsedArgs.hasAcceptanceCriteria === false) {
					query += " AND (acceptanceCriteria IS NULL OR acceptanceCriteria = '[]' OR acceptanceCriteria = '')";
				}
				
				// Tri
				const orderBy = parsedArgs.orderBy || "order";
				const orderDirection = parsedArgs.orderDirection || "ASC";
				// Utiliser des guillemets pour √©viter les conflits avec les mots r√©serv√©s SQL
				const safeOrderBy = orderBy === "order" ? '"order"' : orderBy;
				query += ` ORDER BY ${safeOrderBy} ${orderDirection}`;
				
				// Limite
				if (parsedArgs.limit) {
					query += " LIMIT ?";
					params.push(parsedArgs.limit);
				}
				
				const filteredStories = dbFiltered.prepare(query).all(...params);
				
				if (filteredStories.length === 0) {
					return `‚ùå Aucune user story trouv√©e avec les crit√®res sp√©cifi√©s.`;
				}
				
				// Formater le r√©sultat
				let filteredSummary = `## üîç User Stories filtr√©es (${filteredStories.length})\n\n`;
				
				// Ajouter les crit√®res de filtrage utilis√©s
				const filters = [];
				if (parsedArgs.status) filters.push(`Statut: ${parsedArgs.status}`);
				if (parsedArgs.epic) filters.push(`Epic: ${parsedArgs.epic}`);
				if (parsedArgs.priority) filters.push(`Priorit√©: ${parsedArgs.priority}`);
				if (parsedArgs.minEstimation) filters.push(`Estimation min: ${parsedArgs.minEstimation} jours`);
				if (parsedArgs.maxEstimation) filters.push(`Estimation max: ${parsedArgs.maxEstimation} jours`);
				if (parsedArgs.startDate && parsedArgs.endDate) filters.push(`P√©riode: ${parsedArgs.startDate} √† ${parsedArgs.endDate}`);
				if (parsedArgs.hasAcceptanceCriteria === true) filters.push(`Avec crit√®res d'acceptation`);
				if (parsedArgs.hasAcceptanceCriteria === false) filters.push(`Sans crit√®res d'acceptation`);
				
				if (filters.length > 0) {
					filteredSummary += `### üìã Crit√®res de filtrage\n`;
					filters.forEach(filter => {
						filteredSummary += `- ${filter}\n`;
					});
					filteredSummary += '\n';
				}
				
				// Grouper par statut
				const byStatus = {
					done: filteredStories.filter(s => s.status === 'done'),
					inProgress: filteredStories.filter(s => s.status === 'inProgress'),
					todo: filteredStories.filter(s => s.status === 'todo'),
					blocked: filteredStories.filter(s => s.status === 'blocked'),
					toTest: filteredStories.filter(s => s.status === 'toTest')
				};
				
				if (byStatus.done.length > 0) {
					filteredSummary += `### ‚úÖ Termin√©es (${byStatus.done.length})\n`;
					byStatus.done.forEach(story => {
						const priority = story.priority === 'high' ? 'üî¥' : story.priority === 'medium' ? 'üü°' : 'üü¢';
						filteredSummary += `${priority} **${story.title}** - ${story.estimation || '?'} jours`;
						if (story.epic) filteredSummary += ` (${story.epic})`;
						filteredSummary += '\n';
					});
					filteredSummary += '\n';
				}
				
				if (byStatus.inProgress.length > 0) {
					filteredSummary += `### üîÑ En cours (${byStatus.inProgress.length})\n`;
					byStatus.inProgress.forEach(story => {
						const priority = story.priority === 'high' ? 'üî¥' : story.priority === 'medium' ? 'üü°' : 'üü¢';
						filteredSummary += `${priority} **${story.title}** - ${story.estimation || '?'} jours`;
						if (story.epic) filteredSummary += ` (${story.epic})`;
						filteredSummary += '\n';
					});
					filteredSummary += '\n';
				}
				
				if (byStatus.todo.length > 0) {
					filteredSummary += `### ‚è≥ √Ä faire (${byStatus.todo.length})\n`;
					byStatus.todo.forEach(story => {
						const priority = story.priority === 'high' ? 'üî¥' : story.priority === 'medium' ? 'üü°' : 'üü¢';
						filteredSummary += `${priority} **${story.title}** - ${story.estimation || '?'} jours`;
						if (story.epic) filteredSummary += ` (${story.epic})`;
						filteredSummary += '\n';
					});
					filteredSummary += '\n';
				}
				
				if (byStatus.blocked.length > 0) {
					filteredSummary += `### üöß En difficult√© (${byStatus.blocked.length})\n`;
					byStatus.blocked.forEach(story => {
						const priority = story.priority === 'high' ? 'üî¥' : story.priority === 'medium' ? 'üü°' : 'üü¢';
						filteredSummary += `${priority} **${story.title}** - ${story.estimation || '?'} jours`;
						if (story.epic) filteredSummary += ` (${story.epic})`;
						filteredSummary += '\n';
					});
					filteredSummary += '\n';
				}
				
				if (byStatus.toTest.length > 0) {
					filteredSummary += `### üß™ √Ä recetter (${byStatus.toTest.length})\n`;
					byStatus.toTest.forEach(story => {
						const priority = story.priority === 'high' ? 'üî¥' : story.priority === 'medium' ? 'üü°' : 'üü¢';
						filteredSummary += `${priority} **${story.title}** - ${story.estimation || '?'} jours`;
						if (story.epic) filteredSummary += ` (${story.epic})`;
						filteredSummary += '\n';
					});
					filteredSummary += '\n';
				}
				
				return filteredSummary.replace(/\\n/g, "\n");
				
			case "get_user_story_by_title":
				const dbStory = openDb();
				const storyDetails = dbStory.prepare("SELECT * FROM user_stories WHERE title = ? AND projectId = ?").get(parsedArgs.story_title, parsedArgs.projectId);
				if (!storyDetails) {
					return `‚ùå User story "${parsedArgs.story_title}" non trouv√©e dans le projet.`;
				}
				
				// Formater les d√©tails de la story
				const statusIcon = {
					'done': '‚úÖ',
					'inProgress': 'üîÑ',
					'todo': '‚è≥',
					'blocked': 'üöß',
					'toTest': 'üß™'
				}[storyDetails.status] || '‚ùì';
				
				const priorityIcon = {
					'high': 'üî¥',
					'medium': 'üü°',
					'low': 'üü¢'
				}[storyDetails.priority] || '‚ö™';
				
				let details = `## üìã D√©tails de la User Story\n\n`;
				details += `### ${statusIcon} **${storyDetails.title}**\n\n`;
				details += `| Champ | Valeur |\n`;
				details += `|-------|--------|\n`;
				details += `| **Statut** | ${statusIcon} ${storyDetails.status || 'Non d√©fini'} |\n`;
				details += `| **Priorit√©** | ${priorityIcon} ${storyDetails.priority || 'Non d√©finie'} |\n`;
				details += `| **Estimation** | ${storyDetails.estimation ? `${storyDetails.estimation} jours` : 'Non estim√©e'} |\n`;
				details += `| **Epic** | ${storyDetails.epic || 'Non d√©finie'} |\n`;
				details += `| **R√¥le utilisateur** | ${storyDetails.userRole || 'Non d√©fini'} |\n`;
				details += `| **D√©pendance** | ${storyDetails.dependency || 'Aucune'} |\n`;
				details += `| **ID** | ${storyDetails.id} |\n`;
				
				if (storyDetails.justification) {
					details += `\n### üìù Justification\n\n${storyDetails.justification}\n`;
				}
				
				if (storyDetails.acceptanceCriteria) {
					details += `\n### ‚úÖ Crit√®res d'acceptation\n\n`;
					try {
						// Essayer de parser les crit√®res d'acceptation comme JSON
						const criteria = JSON.parse(storyDetails.acceptanceCriteria);
						if (Array.isArray(criteria)) {
							criteria.forEach((criterion, index) => {
								const status = criterion.checkedDev ? '‚úÖ' : '‚è≥';
								details += `${status} **AC${index + 1}** : ${criterion.label}\n`;
							});
						} else {
							details += storyDetails.acceptanceCriteria;
						}
					} catch (e) {
						// Si ce n'est pas du JSON, afficher tel quel
						details += storyDetails.acceptanceCriteria;
					}
					details += '\n';
				}
				
				return details;
				
			case "get_project_metrics":
				// Impl√©menter directement avec le format optimis√©
				const db = openDb();
				const project = db.prepare("SELECT * FROM projects WHERE id = ?").get(parsedArgs.projectId);
				if (!project) {
					return "‚ùå Projet non trouv√© avec cet ID.";
				}
				
				const totalStories = db.prepare("SELECT COUNT(*) as count FROM user_stories WHERE projectId = ?").get(parsedArgs.projectId);
				const doneStories = db.prepare("SELECT COUNT(*) as count FROM user_stories WHERE projectId = ? AND status = 'done'").get(parsedArgs.projectId);
				const inProgressStories = db.prepare("SELECT COUNT(*) as count FROM user_stories WHERE projectId = ? AND status = 'inProgress'").get(parsedArgs.projectId);
				const todoStories = db.prepare("SELECT COUNT(*) as count FROM user_stories WHERE projectId = ? AND status = 'todo'").get(parsedArgs.projectId);
				const blockedStories = db.prepare("SELECT COUNT(*) as count FROM user_stories WHERE projectId = ? AND status = 'blocked'").get(parsedArgs.projectId);
				const toTestStories = db.prepare("SELECT COUNT(*) as count FROM user_stories WHERE projectId = ? AND status = 'toTest'").get(parsedArgs.projectId);
				
				const completionRate = totalStories.count > 0 ? Math.round((doneStories.count / totalStories.count) * 100) : 0;
				
				let summary = `## üìä M√©triques du projet: ${project.name}\n`;
				summary += `### üéØ Progression globale\n`;
				summary += `| M√©trique | Valeur | Statut |\n`;
				summary += `|----------|--------|--------|\n`;
				// Logique intelligente pour les indicateurs selon l'√¢ge du projet
				const currentDateForStatus = new Date();
				const projectStartDateForStatus = project.createdAt ? new Date(project.createdAt) : null;
				const daysSinceStartForStatus = projectStartDateForStatus ? Math.floor((currentDateForStatus - projectStartDateForStatus) / (1000 * 60 * 60 * 24)) : 0;
				
				let completionStatus;
				if (completionRate >= 80) {
					completionStatus = '‚úÖ';
				} else if (completionRate >= 60) {
					completionStatus = 'üü°';
				} else if (completionRate >= 30) {
					if (daysSinceStartForStatus < 90) {
						completionStatus = 'üü°'; // Normal pour un projet r√©cent
					} else {
						completionStatus = 'üî¥';
					}
				} else {
					if (daysSinceStartForStatus < 30) {
						completionStatus = 'üü°'; // Normal pour un projet tr√®s r√©cent
					} else if (daysSinceStartForStatus < 60) {
						completionStatus = 'üü°'; // Acceptable pour un projet en d√©marrage
					} else {
						completionStatus = 'üî¥';
					}
				}
				
				summary += `| **Taux de completion** | ${completionRate}% | ${completionStatus} |\n`;
				summary += `| **Stories termin√©es** | ${doneStories.count} | ‚úÖ |\n`;
				summary += `| **Stories en cours** | ${inProgressStories.count} | üîÑ |\n`;
				summary += `| **Stories √† faire** | ${todoStories.count} | ‚è≥ |\n`;
				summary += `| **Stories en difficult√©** | ${blockedStories.count} | üöß |\n`;
				summary += `| **Stories √† recetter** | ${toTestStories.count} | üß™ |\n`;
				
				// R√©partition par priorit√©
				const priorityDistribution = db.prepare(`
					SELECT priority, COUNT(*) as count
					FROM user_stories 
					WHERE projectId = ?
					GROUP BY priority
					ORDER BY priority DESC
				`).all(parsedArgs.projectId);
				
				if (priorityDistribution.length > 0) {
					summary += `### üî¥üü°üü¢ R√©partition par priorit√©\n`;
					summary += `| Priorit√© | Nombre | Pourcentage |\n`;
					summary += `|----------|--------|-------------|\n`;
					priorityDistribution.forEach(p => {
						// G√©rer les diff√©rents formats de priorit√©
						let icon, priorityName;
						if (p.priority === 'high' || p.priority === 'Must Have') {
							icon = 'üî¥';
							priorityName = 'Haute';
						} else if (p.priority === 'medium' || p.priority === 'Should Have') {
							icon = 'üü°';
							priorityName = 'Moyenne';
						} else if (p.priority === 'low' || p.priority === 'Could Have') {
							icon = 'üü¢';
							priorityName = 'Basse';
						} else {
							icon = '‚ö™';
							priorityName = p.priority;
						}
						const percentage = Math.round((p.count / totalStories.count) * 100);
						summary += `| ${icon} **${priorityName}** | ${p.count} | ${percentage}% |\n`;
					});
				}
				
				// R√©partition par estimation (limit√© aux 10 plus fr√©quentes)
				const estimationDistribution = db.prepare(`
					SELECT estimation, COUNT(*) as count
					FROM user_stories 
					WHERE projectId = ? AND estimation IS NOT NULL
					GROUP BY estimation
					ORDER BY count DESC
					LIMIT 10
				`).all(parsedArgs.projectId);
				
				if (estimationDistribution.length > 0) {
					summary += `### üìà R√©partition par estimation (top 10)\n`;
					summary += `| Jours | Nombre | Complexit√© |\n`;
					summary += `|--------|--------|------------|\n`;
					estimationDistribution.forEach(e => {
						const level = e.estimation <= 3 ? 'üü¢' : e.estimation <= 8 ? 'üü°' : 'üî¥';
						const complexity = e.estimation <= 3 ? 'Simple' : e.estimation <= 8 ? 'Moyenne' : 'Complexe';
						summary += `| **${e.estimation}** | ${e.count} | ${level} ${complexity} |\n`;
					});
				}
				
				// M√©triques de v√©locit√© par p√©riode (bas√© sur les dates estim√©es)
				if (parsedArgs.includeSprintData !== false) {
					const currentDate = new Date();
					const currentPeriod = currentDate.toISOString().slice(0, 7); // YYYY-MM
					
					const periodStories = db.prepare(`
						SELECT 
							strftime('%Y-%m', estimatedStartDate) as period,
							COUNT(*) as totalStories,
							SUM(CASE WHEN status = 'done' THEN 1 ELSE 0 END) as completedStories,
							AVG(CAST(estimation AS INTEGER)) as avgEstimation
						FROM user_stories 
						WHERE projectId = ? 
							AND estimatedStartDate IS NOT NULL
							AND strftime('%Y-%m', estimatedStartDate) <= ?
						GROUP BY strftime('%Y-%m', estimatedStartDate)
						ORDER BY period DESC
						LIMIT 10
					`).all(parsedArgs.projectId, currentPeriod);
					
					if (periodStories.length > 0) {
						summary += `### üèÉ‚Äç‚ôÇÔ∏è V√©locit√© par p√©riode (p√©riodes pass√©es)\n`;
						summary += `> üìÖ *Analyse bas√©e sur les p√©riodes termin√©es jusqu'√† ${currentPeriod}*\n\n`;
						summary += `| P√©riode | Termin√©es/Total | Taux | Jours moy. | Performance |\n`;
						summary += `|---------|----------------|------|-------------|-------------|\n`;
						periodStories.reverse().forEach(period => { // Remettre dans l'ordre chronologique
							const completionRate = period.totalStories > 0 ? Math.round((period.completedStories / period.totalStories) * 100) : 0;
							
							// Logique intelligente pour la performance selon l'√¢ge du projet
							let status, performance;
							const periodDate = new Date(period.period + '-01');
							const daysSincePeriod = Math.floor((currentDate - periodDate) / (1000 * 60 * 60 * 24));
							
							if (completionRate >= 80) {
								status = '‚úÖ';
								performance = 'Excellent';
							} else if (completionRate >= 60) {
								status = 'üü°';
								performance = 'Bon';
							} else if (completionRate >= 30) {
								if (daysSincePeriod < 30) {
									status = 'üü°';
									performance = 'En cours';
								} else {
									status = 'üî¥';
									performance = '√Ä am√©liorer';
								}
							} else {
								if (daysSincePeriod < 14) {
									status = 'üü°';
									performance = 'D√©marrage';
								} else if (daysSincePeriod < 60) {
									status = 'üü°';
									performance = 'Normal';
								} else {
									status = 'üî¥';
									performance = '√Ä am√©liorer';
								}
							}
							
							summary += `| **${period.period}** | ${period.completedStories}/${period.totalStories} | ${completionRate}% | ${Math.round(period.avgEstimation || 0)} | ${status} ${performance} |\n`;
						});
					}
				}
				
				// Estimation du temps restant
				const avgEstimation = db.prepare(`
					SELECT AVG(CAST(estimation AS INTEGER)) as avg
					FROM user_stories 
					WHERE projectId = ? AND estimation IS NOT NULL
				`).get(parsedArgs.projectId);
				
				const remainingStories = totalStories.count - doneStories.count;
				const estimatedRemainingDays = avgEstimation.avg ? Math.ceil(remainingStories * avgEstimation.avg / 2) : 0;
				
				summary += `### ‚è±Ô∏è Estimations\n`;
				summary += `| M√©trique | Valeur |\n`;
				summary += `|----------|--------|\n`;
				summary += `| **Estimation moyenne** | ${Math.round(avgEstimation.avg || 0)} jours |\n`;
				summary += `| **Stories restantes** | ${remainingStories} |\n`;
				summary += `| **Temps estim√©** | ${estimatedRemainingDays} jours |\n`;
				summary += `| **Hypoth√®se** | 2 jours/story |\n`;
				
				// Ajouter des insights bas√©s sur les donn√©es et la date actuelle
				const currentDate = new Date();
				const projectStartDate = project.createdAt ? new Date(project.createdAt) : null;
				const daysSinceStart = projectStartDate ? Math.floor((currentDate - projectStartDate) / (1000 * 60 * 60 * 24)) : 0;
				
				summary += `> üí° **Insights (${currentDate.toLocaleDateString('fr-FR')}):** `;
				
				// Logique intelligente bas√©e sur la progression du projet
				if (completionRate >= 80) {
					summary += `Excellent taux de completion ! Le projet progresse tr√®s bien.`;
				} else if (completionRate >= 60) {
					summary += `Bon taux de completion. Le projet avance correctement.`;
				} else if (completionRate >= 30) {
					if (daysSinceStart < 30) {
						summary += `Progression normale pour un projet r√©cent (${daysSinceStart} jours). Le taux de completion de ${completionRate}% est coh√©rent avec le d√©but de projet.`;
					} else if (daysSinceStart < 90) {
						summary += `Progression acceptable pour un projet en cours (${daysSinceStart} jours). Le taux de ${completionRate}% est dans la normale pour cette phase.`;
					} else {
						summary += `Taux de completion mod√©r√© (${completionRate}%). Consid√©rez identifier les blocages pour am√©liorer la v√©locit√©.`;
					}
				} else {
					if (daysSinceStart < 14) {
						summary += `Projet tout r√©cent (${daysSinceStart} jours) - le taux de ${completionRate}% est normal pour cette phase initiale.`;
					} else if (daysSinceStart < 60) {
						summary += `Projet en phase de d√©marrage (${daysSinceStart} jours). Le taux de ${completionRate}% est coh√©rent avec cette √©tape.`;
					} else {
						summary += `Taux de completion faible (${completionRate}%). Analysez les causes et ajustez la planification.`;
					}
				}
				
				// Ajouter des recommandations contextuelles
				summary += `\n`;
				summary += `> üéØ **Recommandations:** `;
				if (daysSinceStart < 30) {
					summary += `Concentrez-vous sur la d√©finition et la priorisation des stories. La v√©locit√© s'am√©liorera naturellement.`;
				} else if (daysSinceStart < 90) {
					summary += `Optimisez le workflow et identifiez les goulots d'√©tranglement pour am√©liorer la v√©locit√©.`;
				} else {
					summary += `Analysez les patterns de blocage et optimisez les processus pour acc√©l√©rer la livraison.`;
				}
				summary += `\n`;
				
				return summary;
				
			// Outils d'√©dition de user stories
			case "create_user_story":
				const dbCreate = openDb();
				const id = `${Date.now()}-${Math.floor(Math.random()*10000)}`;
				dbCreate.prepare(`INSERT INTO user_stories (id, projectId, epic, userRole, title, justification, estimation, priority, dependency, acceptanceCriteria, status, "order") VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)`)
					.run(
						id,
						parsedArgs.projectId,
						parsedArgs.epic || null,
						parsedArgs.userRole || null,
						parsedArgs.title,
						parsedArgs.justification || null,
						parsedArgs.estimation || null,
						parsedArgs.priority || null,
						parsedArgs.dependency || null,
						parsedArgs.acceptanceCriteria || "[]", // Valeur par d√©faut pour √©viter la contrainte NOT NULL
						parsedArgs.status || "todo",
						Date.now()
					);
				const story = dbCreate.prepare("SELECT * FROM user_stories WHERE id = ?").get(id);
				return `‚úÖ Nouvelle user story cr√©√©e :\n\n- **ID** : ${story.id}\n- **Titre** : ${story.title}\n- **Statut** : ${story.status}\n- **Priorit√©** : ${story.priority || "-"}\n- **Estimation** : ${story.estimation || "-"}\n- **Epic** : ${story.epic || "-"}`;
				
			case "update_user_story_title":
			case "update_user_story_epic":
			case "update_user_story_user_role":
			case "update_user_story_justification":
			case "update_user_story_estimation":
			case "update_user_story_priority":
			case "update_user_story_dependency":
			case "update_user_story_acceptance_criteria":
			case "update_user_story_status":
				const dbUpdate = openDb();
				// Extraire le nom du champ √† partir du nom de l'outil
				const fieldName = name.replace('update_user_story_', '');
				const fieldLabel = {
					title: "Titre",
					epic: "Epic",
					user_role: "R√¥le utilisateur",
					justification: "Justification",
					estimation: "Estimation",
					priority: "Priorit√©",
					dependency: "D√©pendance",
					acceptance_criteria: "Crit√®res d'acceptation",
					status: "Statut"
				}[fieldName] || fieldName;
				
				// Chercher la story par titre si pas d'ID fourni
				let storyToUpdate;
				if (parsedArgs.id) {
					storyToUpdate = dbUpdate.prepare("SELECT * FROM user_stories WHERE id = ?").get(parsedArgs.id);
				} else if (parsedArgs.story_title) {
					storyToUpdate = dbUpdate.prepare("SELECT * FROM user_stories WHERE title = ? AND projectId = ?").get(parsedArgs.story_title, parsedArgs.projectId);
				}
				
				if (!storyToUpdate) {
					return `‚ùå User story non trouv√©e. V√©rifiez l'ID ou le titre.`;
				}
				
				// Mettre √† jour le champ
				let value = parsedArgs.value || parsedArgs.status || parsedArgs.title || parsedArgs.epic || parsedArgs.user_role || parsedArgs.justification || parsedArgs.estimation || parsedArgs.priority || parsedArgs.dependency || parsedArgs.acceptance_criteria;
				
				// G√©rer les valeurs par d√©faut pour √©viter les contraintes NOT NULL
				if (fieldName === 'acceptance_criteria' && !value) {
					value = "[]";
				}
				
				dbUpdate.prepare(`UPDATE user_stories SET ${fieldName} = ? WHERE id = ?`).run(value, storyToUpdate.id);
				
				const updated = dbUpdate.prepare("SELECT * FROM user_stories WHERE id = ?").get(storyToUpdate.id);
				return `‚úèÔ∏è User story modifi√©e :\n\n- **ID** : ${updated.id}\n- **Titre** : ${updated.title}\n- **${fieldLabel}** : ${updated[fieldName] || "-"}`;
				
			case "delete_user_story":
				const dbDelete = openDb();
				let storyToDelete;
				if (parsedArgs.id) {
					storyToDelete = dbDelete.prepare("SELECT * FROM user_stories WHERE id = ?").get(parsedArgs.id);
				} else if (parsedArgs.story_title) {
					storyToDelete = dbDelete.prepare("SELECT * FROM user_stories WHERE title = ? AND projectId = ?").get(parsedArgs.story_title, parsedArgs.projectId);
				}
				
				if (!storyToDelete) {
					return `‚ùå User story non trouv√©e. V√©rifiez l'ID ou le titre.`;
				}
				
				dbDelete.prepare("DELETE FROM user_stories WHERE id = ?").run(storyToDelete.id);
				return `üóëÔ∏è User story supprim√©e :\n\n- **ID** : ${storyToDelete.id}\n- **Titre** : ${storyToDelete.title}`;
				
			default:
				throw new Error(`Outil MCP inconnu: ${name}`);
		}
	} catch (error) {
		console.error("Erreur lors de l'ex√©cution du tool MCP:", error);
		return `‚ùå Erreur lors de l'ex√©cution de l'outil: ${error.message}`;
	}
}

// Endpoint POST /ai-chat : proxy OpenAI Responses API (non-streaming)
router.post("/ai-chat", async (req, res) => {
	const { prompt, openaiApiKey, history, tools, tool_choice, model } = req.body;
	if ((!prompt && !Array.isArray(history)) || !openaiApiKey) {
		return res
			.status(400)
			.json({ error: "Prompt ou historique et cl√© OpenAI requis." });
	}
	const input =
		Array.isArray(history) && history.length > 0
			? history
			: [
				{
					role: "user",
					content: prompt,
				},
			];

	const client = new OpenAI({ apiKey: openaiApiKey });

	try {
		// Configuration des headers pour JSON (pas SSE)
		res.setHeader("Content-Type", "application/json");
		res.setHeader("Access-Control-Allow-Origin", "*");
		res.setHeader("Access-Control-Allow-Headers", "Content-Type");
		
		// Construction dynamique du payload OpenAI pour int√©grer MCP
		const payload = {
			model: model || "gpt-4o-mini",
			messages: input,
			stream: false, // Pas de streaming pour tester
		};
		
		const completion = await client.chat.completions.create(payload);
		
		// Envoyer la r√©ponse compl√®te
		res.json({
			success: true,
			content: completion.choices[0].message.content,
			usage: completion.usage
		});
	} catch (err) {
		console.error("Erreur dans ai-chat:", err);
		res.status(500).json({ error: err.message });
	}
});

// Endpoint POST /ai-chat-stream : proxy OpenAI Responses API (streaming)
router.post("/ai-chat-stream", async (req, res) => {
	const { prompt, openaiApiKey, history, tools, tool_choice, model } = req.body;
	if ((!prompt && !Array.isArray(history)) || !openaiApiKey) {
		return res
			.status(400)
			.json({ error: "Prompt ou historique et cl√© OpenAI requis." });
	}
	const input =
		Array.isArray(history) && history.length > 0
			? history
			: [
				{
					role: "user",
					content: prompt,
				},
			];

	const client = new OpenAI({ apiKey: openaiApiKey });

	try {
		// Configuration des headers SSE
		res.setHeader("Content-Type", "text/event-stream");
		res.setHeader("Cache-Control", "no-cache");
		res.setHeader("Connection", "keep-alive");
		res.setHeader("Access-Control-Allow-Origin", "*");
		res.setHeader("Access-Control-Allow-Headers", "Content-Type");
		
		let clientClosed = false;
		req.on("close", () => {
			clientClosed = true;
		});
		
		// Construction du payload OpenAI
		const payload = {
			model: model || "gpt-4o-mini",
			messages: input,
			stream: true, // Streaming activ√©
		};
		
		const stream = await client.chat.completions.create(payload);
		
		// Envoyer un message initial pour maintenir la connexion
		res.write("data: {\"type\": \"connected\"}\n\n");
		res.flush && res.flush();

		// Lire et envoyer les √©v√©nements imm√©diatement
		for await (const event of stream) {
			if (clientClosed) {
				break;
			}
			
			// Envoyer imm√©diatement
			const data = `data: ${JSON.stringify(event)}\n\n`;
			res.write(data);
			
			// Forcer l'envoi
			if (res.flush) {
				res.flush();
			}
		}
		
		if (!clientClosed) {
			res.end();
		}
	} catch (err) {
		console.error("Erreur dans ai-chat-stream:", err);
		try {
			res.write(`data: {\"error\": \"${err.message}\"}\n\n`);
		} catch (writeErr) {
			console.error("Erreur lors de l'√©criture de l'erreur:", writeErr);
		}
		res.end();
	}
});

// Endpoint GET /ai-chat-stream-events : endpoint EventSource pour le streaming
router.get("/ai-chat-stream-events", (req, res) => {
	// Configuration des headers SSE
	res.setHeader("Content-Type", "text/event-stream");
	res.setHeader("Cache-Control", "no-cache");
	res.setHeader("Connection", "keep-alive");
	res.setHeader("Access-Control-Allow-Origin", "*");
	res.setHeader("Access-Control-Allow-Headers", "Content-Type");
	
	// Envoyer un message initial
	res.write("data: {\"type\": \"connected\"}\n\n");
	res.flush && res.flush();
	
	// Stocker la connexion pour l'utiliser plus tard
	req.app.locals.eventSourceConnections = req.app.locals.eventSourceConnections || [];
	req.app.locals.eventSourceConnections.push(res);
	
	// G√©rer la fermeture de la connexion
	req.on("close", () => {
		const index = req.app.locals.eventSourceConnections.indexOf(res);
		if (index > -1) {
			req.app.locals.eventSourceConnections.splice(index, 1);
		}
	});
});

// Endpoint POST /ai-chat-stream-init : initialiser le streaming
router.post("/ai-chat-stream-init", async (req, res) => {
	const { prompt, openaiApiKey, history, tools, tool_choice, model } = req.body;
	if ((!prompt && !Array.isArray(history)) || !openaiApiKey) {
		return res.status(400).json({ error: "Prompt ou historique et cl√© OpenAI requis." });
	}
	
	const input = Array.isArray(history) && history.length > 0 ? history : [{ role: "user", content: prompt }];
	const client = new OpenAI({ apiKey: openaiApiKey });
	
	try {
		// D√©finir les outils MCP comme function calls OpenAI
		const mcpTools = tools ? [
			{
				type: "function",
				function: {
					name: "list_projects",
					description: "Lister tous les projets disponibles",
					parameters: {
						type: "object",
						properties: {},
						required: []
					}
				}
			},
			{
				type: "function",
				function: {
					name: "get_project_user_stories",
					description: "Obtenir les user stories d'un projet sp√©cifique",
					parameters: {
						type: "object",
						properties: {
							projectId: {
								type: "string",
								description: "L'ID du projet"
							}
						},
						required: ["projectId"]
					}
				}
			},
			{
				type: "function",
				function: {
					name: "get_project_metrics",
					description: "Obtenir les m√©triques d√©taill√©es d'un projet (progression, v√©locit√©, estimations)",
					parameters: {
						type: "object",
						properties: {
							projectId: {
								type: "string",
								description: "L'ID du projet"
							}
						},
						required: ["projectId"]
					}
				}
			},
			{
				type: "function",
				function: {
					name: "get_user_story_by_title",
					description: "Obtenir les d√©tails d'une user story sp√©cifique par son titre",
					parameters: {
						type: "object",
						properties: {
							projectId: {
								type: "string",
								description: "L'ID du projet"
							},
							story_title: {
								type: "string",
								description: "Le titre exact de la user story"
							}
						},
						required: ["projectId", "story_title"]
					}
				}
			},
			{
				type: "function",
				function: {
					name: "get_filtered_user_stories",
					description: "Filtrer et afficher les user stories selon des crit√®res sp√©cifiques : statut, epic, priorit√©, estimation, dates, crit√®res d'acceptation",
					parameters: {
						type: "object",
						properties: {
							projectId: {
								type: "string",
								description: "L'ID du projet"
							},
							status: {
								type: "string",
								description: "Filtrer par statut (done, inProgress, todo, blocked, toTest)"
							},
							epic: {
								type: "string",
								description: "Filtrer par epic (recherche partielle)"
							},
							priority: {
								type: "string",
								description: "Filtrer par priorit√© (high, medium, low)"
							},
							minEstimation: {
								type: "number",
								description: "Estimation minimale en jours"
							},
							maxEstimation: {
								type: "number",
								description: "Estimation maximale en jours"
							},
							startDate: {
								type: "string",
								description: "Date de d√©but pour le filtrage par p√©riode (YYYY-MM-DD)"
							},
							endDate: {
								type: "string",
								description: "Date de fin pour le filtrage par p√©riode (YYYY-MM-DD)"
							},
							hasAcceptanceCriteria: {
								type: "boolean",
								description: "Filtrer par pr√©sence de crit√®res d'acceptation (true/false)"
							},
							orderBy: {
								type: "string",
								description: "Champ de tri (order, title, priority, estimation, status)"
							},
							orderDirection: {
								type: "string",
								description: "Direction du tri (ASC/DESC)"
							},
							limit: {
								type: "number",
								description: "Limite du nombre de r√©sultats"
							}
						},
						required: ["projectId"]
					}
				}
			},
			// Outils d'√©dition de user stories
			{
				type: "function",
				function: {
					name: "create_user_story",
					description: "Cr√©er une nouvelle user story dans le projet sp√©cifi√©",
					parameters: {
						type: "object",
						properties: {
							projectId: {
								type: "string",
								description: "L'ID du projet"
							},
							title: {
								type: "string",
								description: "Le titre de la user story"
							},
							epic: {
								type: "string",
								description: "L'epic de la user story"
							},
							userRole: {
								type: "string",
								description: "Le r√¥le utilisateur"
							},
							justification: {
								type: "string",
								description: "La justification"
							},
							estimation: {
								type: "number",
								description: "L'estimation en jours"
							},
							priority: {
								type: "string",
								description: "La priorit√© (high, medium, low)"
							},
							status: {
								type: "string",
								description: "Le statut (todo, inProgress, done, blocked, toTest)"
							}
						},
						required: ["projectId", "title"]
					}
				}
			},
			{
				type: "function",
				function: {
					name: "update_user_story_status",
					description: "Modifier le statut d'une user story",
					parameters: {
						type: "object",
						properties: {
							projectId: {
								type: "string",
								description: "L'ID du projet"
							},
							story_title: {
								type: "string",
								description: "Le titre de la user story √† modifier"
							},
							status: {
								type: "string",
								description: "Le nouveau statut (todo, inProgress, done, blocked, toTest)"
							}
						},
						required: ["projectId", "story_title", "status"]
					}
				}
			},
			{
				type: "function",
				function: {
					name: "update_user_story_title",
					description: "Modifier le titre d'une user story",
					parameters: {
						type: "object",
						properties: {
							projectId: {
								type: "string",
								description: "L'ID du projet"
							},
							story_title: {
								type: "string",
								description: "Le titre actuel de la user story"
							},
							title: {
								type: "string",
								description: "Le nouveau titre"
							}
						},
						required: ["projectId", "story_title", "title"]
					}
				}
			},
			{
				type: "function",
				function: {
					name: "delete_user_story",
					description: "Supprimer une user story",
					parameters: {
						type: "object",
						properties: {
							projectId: {
								type: "string",
								description: "L'ID du projet"
							},
							story_title: {
								type: "string",
								description: "Le titre de la user story √† supprimer"
							}
						},
						required: ["projectId", "story_title"]
					}
				}
			}
		] : [];
		
		const payload = {
			model: model || "gpt-4o-mini",
			messages: input,
			stream: true,
			tools: mcpTools,
			tool_choice: "auto"
		};
		
		const stream = await client.chat.completions.create(payload);
		
		// Envoyer les √©v√©nements √† toutes les connexions EventSource
		let toolCallInProgress = false;
		let currentToolCall = null;
		
		for await (const event of stream) {
			// V√©rifier si c'est un tool call
			if (event.choices && event.choices[0] && event.choices[0].delta && event.choices[0].delta.tool_calls) {
				toolCallInProgress = true;
				if (!currentToolCall) {
					currentToolCall = {
						id: "",
						type: "function",
						function: { name: "", arguments: "" }
					};
				}
				
				// Accumuler les donn√©es du tool call
				const toolCall = event.choices[0].delta.tool_calls[0];
				if (toolCall.id) currentToolCall.id = toolCall.id;
				if (toolCall.function && toolCall.function.name) currentToolCall.function.name = toolCall.function.name;
				if (toolCall.function && toolCall.function.arguments) currentToolCall.function.arguments += toolCall.function.arguments;
			}
			
			// Si c'est la fin d'un tool call, l'ex√©cuter
			if (toolCallInProgress && event.choices && event.choices[0] && event.choices[0].finish_reason === "tool_calls") {
									// Ex√©cuter le tool call MCP
					try {
						// Envoyer un message de progression
						const progressEvent = {
							choices: [{
								index: 0,
								delta: {
									role: "assistant",
									content: `üîç R√©cup√©ration des donn√©es...`
								},
								finish_reason: null
							}]
						};
						
						const progressConnections = req.app.locals.eventSourceConnections || [];
						progressConnections.forEach(connection => {
							try {
								connection.write(`data: ${JSON.stringify(progressEvent)}\n\n`);
								connection.flush && connection.flush();
							} catch (err) {
								console.error("Erreur envoi progress √† une connexion:", err);
							}
						});
						
						const result = await executeMcpTool(currentToolCall);
						
						// Formater le r√©sultat pour qu'il soit plus lisible
						let formattedResult;
						if (currentToolCall.function.name === "get_project_user_stories") {
							// Pour les user stories, utiliser le format optimis√©
							const userStories = result;
							if (userStories.length === 0) {
								formattedResult = "‚ùå Aucune user story trouv√©e pour ce projet.";
							} else {
								let summary = `## üìã User Stories du projet (${userStories.length})\n`;
								
								// Grouper par statut
								const byStatus = {
									done: userStories.filter(s => s.status === 'done'),
									inProgress: userStories.filter(s => s.status === 'inProgress'),
									todo: userStories.filter(s => s.status === 'todo'),
									blocked: userStories.filter(s => s.status === 'blocked'),
									toTest: userStories.filter(s => s.status === 'toTest')
								};
								
								if (byStatus.done.length > 0) {
									const displayCount = Math.min(byStatus.done.length, 20);
									summary += `### ‚úÖ Termin√©es (${byStatus.done.length} total, affichage des ${displayCount} plus r√©centes)\n`;
									byStatus.done.slice(0, displayCount).forEach(story => {
										const priority = story.priority === 'high' ? 'üî¥' : story.priority === 'medium' ? 'üü°' : 'üü¢';
										summary += `${priority} **${story.title}** - ${story.estimation || '?'} jours\n`;
									});
									if (byStatus.done.length > displayCount) {
										summary += `... et ${byStatus.done.length - displayCount} autres stories termin√©es\n`;
									}
									summary += '\n';
								}
								
								if (byStatus.inProgress.length > 0) {
									const displayCount = Math.min(byStatus.inProgress.length, 20);
									summary += `### üîÑ En cours (${byStatus.inProgress.length} total, affichage des ${displayCount} plus r√©centes)\n`;
									byStatus.inProgress.slice(0, displayCount).forEach(story => {
										const priority = story.priority === 'high' ? 'üî¥' : story.priority === 'medium' ? 'üü°' : 'üü¢';
										summary += `${priority} **${story.title}** - ${story.estimation || '?'} jours\n`;
									});
									if (byStatus.inProgress.length > displayCount) {
										summary += `... et ${byStatus.inProgress.length - displayCount} autres stories en cours\n`;
									}
									summary += '\n';
								}
								
								if (byStatus.todo.length > 0) {
									const displayCount = Math.min(byStatus.todo.length, 20);
									summary += `### ‚è≥ √Ä faire (${byStatus.todo.length} total, affichage des ${displayCount} plus prioritaires)\n`;
									byStatus.todo.slice(0, displayCount).forEach(story => {
										const priority = story.priority === 'high' ? 'üî¥' : story.priority === 'medium' ? 'üü°' : 'üü¢';
										summary += `${priority} **${story.title}** - ${story.estimation || '?'} jours\n`;
									});
									if (byStatus.todo.length > displayCount) {
										summary += `... et ${byStatus.todo.length - displayCount} autres stories √† faire\n`;
									}
									summary += '\n';
								}
								
								if (byStatus.blocked.length > 0) {
									const displayCount = Math.min(byStatus.blocked.length, 20);
									summary += `### üöß En difficult√© (${byStatus.blocked.length} total, affichage des ${displayCount} plus r√©centes)\n`;
									byStatus.blocked.slice(0, displayCount).forEach(story => {
										const priority = story.priority === 'high' ? 'üî¥' : story.priority === 'medium' ? 'üü°' : 'üü¢';
										summary += `${priority} **${story.title}** - ${story.estimation || '?'} jours\n`;
									});
									if (byStatus.blocked.length > displayCount) {
										summary += `... et ${byStatus.blocked.length - displayCount} autres stories en difficult√©\n`;
									}
									summary += '\n';
								}
								
								if (byStatus.toTest.length > 0) {
									const displayCount = Math.min(byStatus.toTest.length, 20);
									summary += `### üß™ √Ä recetter (${byStatus.toTest.length} total, affichage des ${displayCount} plus r√©centes)\n`;
									byStatus.toTest.slice(0, displayCount).forEach(story => {
										const priority = story.priority === 'high' ? 'üî¥' : story.priority === 'medium' ? 'üü°' : 'üü¢';
										summary += `${priority} **${story.title}** - ${story.estimation || '?'} jours\n`;
									});
									if (byStatus.toTest.length > displayCount) {
										summary += `... et ${byStatus.toTest.length - displayCount} autres stories √† recetter\n`;
									}
									summary += '\n';
								}
								
								formattedResult = summary;
							}
						} else if (currentToolCall.function.name === "get_project_metrics") {
							// Pour les m√©triques, le r√©sultat est d√©j√† format√©
							formattedResult = result;
						} else if (currentToolCall.function.name === "get_filtered_user_stories") {
							// Pour le filtrage des user stories, le r√©sultat est d√©j√† format√© en Markdown
							formattedResult = result;
						} else if (currentToolCall.function.name === "get_user_story_by_title") {
							// Pour les d√©tails d'une user story, le r√©sultat est d√©j√† format√© en Markdown
							formattedResult = result;
						} else if (currentToolCall.function.name.startsWith("update_user_story_") || currentToolCall.function.name === "create_user_story" || currentToolCall.function.name === "delete_user_story") {
							// Pour les outils d'√©dition, le r√©sultat est d√©j√† format√© en Markdown
							formattedResult = result;
						} else {
							// Pour les autres outils, utiliser le format JSON mais plus lisible
							formattedResult = JSON.stringify(result, null, 2);
						}
						
											// Envoyer le r√©sultat du tool call au client
					const toolResultEvent = {
						choices: [{
							index: 0,
							delta: {
								role: "assistant",
								content: formattedResult
							},
							finish_reason: "stop"
						}]
					};
				
				// Envoyer le r√©sultat du tool call
				const connections = req.app.locals.eventSourceConnections || [];
				connections.forEach(connection => {
					try {
						connection.write(`data: ${JSON.stringify(toolResultEvent)}\n\n`);
						connection.flush && connection.flush();
					} catch (err) {
						console.error("Erreur envoi tool result √† une connexion:", err);
					}
				});
					
					toolCallInProgress = false;
					currentToolCall = null;
					break;
				} catch (err) {
					console.error("Erreur lors de l'ex√©cution du tool call:", err);
					
					// Envoyer l'erreur du tool call au client
					const toolErrorEvent = {
						choices: [{
							index: 0,
							delta: {
								role: "assistant",
								content: `D√©sol√©, je n'ai pas pu acc√©der aux donn√©es demand√©es. Erreur: ${err.message}`
							},
							finish_reason: "stop"
						}]
					};
					
					const connections = req.app.locals.eventSourceConnections || [];
					connections.forEach(connection => {
						try {
							connection.write(`data: ${JSON.stringify(toolErrorEvent)}\n\n`);
							connection.flush && connection.flush();
						} catch (writeErr) {
							console.error("Erreur envoi tool error √† une connexion:", writeErr);
						}
					});
					
					toolCallInProgress = false;
					currentToolCall = null;
				}
			}
			
			// Envoyer l'√©v√©nement normalement si pas de tool call en cours
			if (!toolCallInProgress) {
				const connections = req.app.locals.eventSourceConnections || [];
				connections.forEach(connection => {
					try {
						connection.write(`data: ${JSON.stringify(event)}\n\n`);
						connection.flush && connection.flush();
					} catch (err) {
						console.error("Erreur envoi √† une connexion:", err);
					}
				});
			}
		}
		
		res.json({ success: true });
	} catch (err) {
		console.error("Erreur dans ai-chat-stream-init:", err);
		
		// Envoyer l'erreur aux clients EventSource connect√©s
		const connections = req.app.locals.eventSourceConnections || [];
		connections.forEach(connection => {
			try {
				connection.write(`data: ${JSON.stringify({ error: err.message })}\n\n`);
				connection.flush && connection.flush();
			} catch (writeErr) {
				console.error("Erreur lors de l'envoi de l'erreur:", writeErr);
			}
		});
		
		res.status(500).json({ error: err.message });
	}
});

export default router;
